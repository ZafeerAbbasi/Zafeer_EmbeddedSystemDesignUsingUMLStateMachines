//$file${HSMs::../Core/Src::clockalarm_sm.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: 003_QHSM_ClockAlarm.qm
// File:  ${HSMs::../Core/Src::clockalarm_sm.c}
//
// This code has been generated by QM 6.0.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open source software: you can redistribute it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// NOTE:
// Alternatively, this generated code may be distributed under the terms
// of Quantum Leaps commercial licenses, which expressly supersede the GNU
// General Public License and are specifically designed for licensees
// interested in retaining the proprietary status of their code.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${HSMs::../Core/Src::clockalarm_sm.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpc.h"
#include "clockalarm_sm.h"
#include "main.h"

//$declare${HSMs::CLKALRM} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${HSMs::CLKALRM} ...........................................................
typedef struct CLKALRM {
// protected:
    QHsm super;

// private:

    /*
    Holds the time information during clock/alarm setting.
    Stores the number of seconds.

    Note: Depending on the value of the "timeMode" element, this variable will hold time in 24H or 12H format.
    */
    uint32_t tempTime;

    /*
    User configured Alarm Time.
    Stores the time in number of seconds.

    Note: The variable holds the time in 24H format.
    */
    uint32_t alarmTime;

    /*
    Alarm ON/OFF status.
    */
    uint8_t alarmStatus;

    /*
    Time Mode: 24H or 12H
    */
    uint8_t timeMode;

// private state histories
    QStateHandler hist_stateClock;
} CLKALRM;

/*
Updated by the timer ISR every 100ms.
Stores the time in number of 100 ms.
For example,
currTime = 1;    //100ms -> 00:00:00.1
currTime = 9;    //900ms -> 00:00:00.9
currTime = 10;   //1000ms  -> 00:00:01.0
currTime = 605;  //60.5 seconds -> 00:01:00.55

Note: This variable holds the time in 24H format.
*/
extern uint32_t CLKALRM_currTime;

/*
Main Application Object
*/
extern CLKALRM CLKALRM_zMainObj;

// public:

/*
This returns the value of currTime
*/
static uint32_t CLKALRM_GetCurrentTime(void);
static void CLKALRM_UpdateCurrentTime(void);
static void CLKALRM_SetCurrentTime(uint32_t newCurrTime);

// protected:
static QState CLKALRM_initial(CLKALRM * const me, void const * const par);
static QState CLKALRM_stateClock(CLKALRM * const me, QEvt const * const e);
static QState CLKALRM_stateSetting(CLKALRM * const me, QEvt const * const e);
static QState CLKALRM_stateClockSetting(CLKALRM * const me, QEvt const * const e);
static QState CLKALRM_stateAlarmSetting(CLKALRM * const me, QEvt const * const e);
static QState CLKALRM_stateTicking(CLKALRM * const me, QEvt const * const e);
static QState CLKALRM_stateAlarm(CLKALRM * const me, QEvt const * const e);
//$enddecl${HSMs::CLKALRM} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${HSMs::CLKALRM_Ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${HSMs::CLKALRM_Ctor} ......................................................
void CLKALRM_Ctor(void) {
    /* Create main object and send to Initial State */
    QHsm_ctor( &CLKALRM_zMainObj.super, Q_STATE_CAST( CLKALRM_initial ) );
}
//$enddef${HSMs::CLKALRM_Ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 /* Separate Definition Directive Since the function is not local to the class, i.e. can be useed outside the clockalarm_sm.c *///$define${HSMs::CLKALRM} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${HSMs::CLKALRM} ...........................................................
uint32_t CLKALRM_currTime;
CLKALRM CLKALRM_zMainObj;

//${HSMs::CLKALRM::GetCurrentTime} ...........................................
static uint32_t CLKALRM_GetCurrentTime(void) {
    {
        /* Do something */
    }
}

//${HSMs::CLKALRM::UpdateCurrentTime} ........................................
static void CLKALRM_UpdateCurrentTime(void) {
    if( ++CLKALRM_currTime == MAX_TIME )
    {
        CLKALRM_currTime = 0;
    }
}

//${HSMs::CLKALRM::SetCurrentTime} ...........................................
static void CLKALRM_SetCurrentTime(uint32_t newCurrTime) {
    __disable_irq()
}

//${HSMs::CLKALRM::SM} .......................................................
static QState CLKALRM_initial(CLKALRM * const me, void const * const par) {
    //${HSMs::CLKALRM::SM::initial}
    // state history attributes
    me->hist_stateClock = Q_STATE_CAST(&CLKALRM_stateTicking);
    return Q_TRAN(&CLKALRM_stateTicking);
}

//${HSMs::CLKALRM::SM::stateClock} ...........................................
static QState CLKALRM_stateClock(CLKALRM * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${HSMs::CLKALRM::SM::stateClock}
        case Q_EXIT_SIG: {
            // save deep history
            me->hist_stateClock = QHsm_state(Q_HSM_UPCAST(me));
            status_ = Q_HANDLED();
            break;
        }
        //${HSMs::CLKALRM::SM::stateClock::ALARM}
        case ALARM_SIG: {
            status_ = Q_TRAN(&CLKALRM_stateAlarm);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${HSMs::CLKALRM::SM::stateClock::stateSetting} .............................
static QState CLKALRM_stateSetting(CLKALRM * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${HSMs::CLKALRM::SM::stateClock::stateSetting::ABORT}
        case ABORT_SIG: {
            status_ = Q_TRAN(&CLKALRM_stateTicking);
            break;
        }
        //${HSMs::CLKALRM::SM::stateClock::stateSetting::OK}
        case OK_SIG: {
            status_ = Q_TRAN(&CLKALRM_stateTicking);
            break;
        }
        default: {
            status_ = Q_SUPER(&CLKALRM_stateClock);
            break;
        }
    }
    return status_;
}

//${HSMs::CLKALRM::SM::stateClock::stateSetting::stateClockSetting} ..........
static QState CLKALRM_stateClockSetting(CLKALRM * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&CLKALRM_stateSetting);
            break;
        }
    }
    return status_;
}

//${HSMs::CLKALRM::SM::stateClock::stateSetting::stateAlarmSetting} ..........
static QState CLKALRM_stateAlarmSetting(CLKALRM * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&CLKALRM_stateSetting);
            break;
        }
    }
    return status_;
}

//${HSMs::CLKALRM::SM::stateClock::stateTicking} .............................
static QState CLKALRM_stateTicking(CLKALRM * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${HSMs::CLKALRM::SM::stateClock::stateTicking::SET}
        case SET_SIG: {
            status_ = Q_TRAN(&CLKALRM_stateClockSetting);
            break;
        }
        //${HSMs::CLKALRM::SM::stateClock::stateTicking::OK}
        case OK_SIG: {
            status_ = Q_TRAN(&CLKALRM_stateAlarmSetting);
            break;
        }
        default: {
            status_ = Q_SUPER(&CLKALRM_stateClock);
            break;
        }
    }
    return status_;
}

//${HSMs::CLKALRM::SM::stateAlarm} ...........................................
static QState CLKALRM_stateAlarm(CLKALRM * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${HSMs::CLKALRM::SM::stateAlarm::OK}
        case OK_SIG: {
            status_ = Q_TRAN_HIST(me->hist_stateClock);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
//$enddef${HSMs::CLKALRM} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    CLKALRM_UpdateCurrentTime( );
}
